@[TOC]

# 前言
我这两天参加了蓝桥杯大赛，在市赛中获得了二等奖成绩（考得一般，只超过了 76% 的同学），进入省赛。我参加的是4月23日（周六）的比赛，所以提前来做做4月17日的刷题工作，大家凑合着看看吧，我考完了再给大家分享我的考试经过。

# 刷题，走起
有几个题，我们一起来看看吧，如果有不对的地方请大家指出来！

## 编程实现：比较大小

> 题目描述：
给定两个正整数N和M(0<N<200，0<M<200，N≠M)，比较两个正整数的大小，然后将较大的一个正整数输出。
例如：N=145，M=100，比较后145大于100，故输出145。

```cpp
// Author:PanDaoxi
#include <iostream>
using namespace std;
int main(){
	int n,m;
	cin>>n>>m;
	cout<<(n>m?n:m);
	return 0;
} 
```

## 编程实现：分解整数
> 题目描述：
给定一个正整数N，然后将N分解成3个正整数之和。计算出共有多少种符合要求的分解方法。
要求：
1）分解的3个正整数各不相同；
2）分解的3个正整数中都不含数字3和7。
如：N为8，可分解为（1，1，6）、（1，2，5）、（1，3，4）、（2，2，4）、（2，3，3），其中满足要求的分解方法有1种，为（1，2，5）。

懒得写深搜（犯懒，再一个有点懵）， 
直接套循环，模拟算法，别人看起来可能有点可笑。。

```cpp
// Author:PanDaoxi
#include <iostream>
using namespace std;
int main(){
	int n,sum=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				if(i+j+k==n){
					if(i!=3&&j!=3&&k!=3&&i!=7&&j!=7&&k!=7&&i!=j&&i!=k&&j!=k&&i<j&&j<k){
						//cout<<i<<" "<<j<<" "<<k<<endl;
						sum++;
					}
				}
			}
		}
	}
	cout<<sum;
	return 0;
}
```
## 编程实现：组合（待思考）

> 提示信息： 因数：因数是指整数a除以整数b(b≠0) 的商正好是整数而没有余数，我们就说b是a的因数。
> 公因数：给定若干个整数，如果有一个(些)数是它们共同的因数，那么这个(些)数就叫做它们的公因数。
> 互质数：公因数只有1的两个非零自然数，叫做互质数；例如：2和3，公因数只有1，为互质数。 题目描述：
> 某商店将一种糖果按照数量打包成N和M两种规格来售卖（N和M为互质数，且N和M有无数包）。这样的售卖方式会限制一些数量的糖果不能买到。那么在给出N和M的值，请你计算出最多不能买到的糖果数量。
> 例如：
> 当N=3，M=5，3和5为互质数，不能买到的糖果数量有1，2，4，7，最多不能买到的糖果数量就是7，7之后的任何数量的糖果都是可以通过组合购买到的。

看着就麻烦，啊啊啊！！！
我又不会集合，不会穷举，这个……
我网上冲了个浪，参考了一下 [**博客园用户 Aikoin 的文章**](https://www.cnblogs.com/Aikoin/p/10504719.html)，大家可以一起看看，主要是这样几句话：

> 做这道题有一个结论可以直接用：两个互质数a、b的最大不能组合数为ab-a-b。下面给出详细证明（参考）：
> 
> 如果有离散数学的基础，我们知道可以把所有非负整数划分成a个模a同余等价类，记为[0]，[1]，[2]，...，[a-1]，分别为ak，ak+1，ak+2，…，ak+(a-1)，（k∈Z）。b的倍数一定分布在这a个等价类中，又因为gcd(a,b)=1，所以每个等价类中都有b的倍数，且均分分布（这边想不通可以自己取两个数比画一下，就很好理解了）。特别的，ab∈[0]。设bKi是等价类[i]中最小的b的倍数，那么该等价类中bKi后的所有数都能表示成ax+bKi，一定能被组合出来。显然，最大的bKi后面的所有连续整数都可以被组合出来，而要找到最大不能组合数，我们只需考虑最大的bKi前面的数字即可。把所有的bKi列出来，有{0，b，2b，...，(a-1)b}。很显然(a-1)b就是最大的bKi，而在其他a-1个等价类中，必定有比它小且能被组合的数，这些数就是(a-1)b-1，(a-1)b-2，...，(a-1)b-(a-1)。所以最大不能被组合数就是(a-1)b-a，即ab-a-b。
> 
> 为了便于理解，我以4、7为例画了个图表，结合图表应该很容易就能看懂上面的证明过程：
> ![在这里插入图片描述](https://pic.2ge.org/cdn/?url=https://img-blog.csdnimg.cn/img_convert/adddc79f6961a85079cb71cb81debbfe.png#pic_center)

别问我对于这一大段话懂不懂，我也不明白，看看这个表格呢？这有待我们研究。先把代码贴在这：

```cpp
// Author:PanDaoxi
#include <iostream>
using namespace std;
int main(){
	int m,n;
	cin>>m>>n;
	cout<<m*n-m-n;
	return 0;
} 
```

# 参考答案
## 第一题

```cpp
#include <iostream>
using namespace std;

int main(){
	int n,m;
	cin >> n >> m;
	cout << max(n,m) << endl; 
	//方式二  if...else
	//方式三  三木运算符 
	return 0;
}

```
## 第二题

```cpp
#include <iostream>
using namespace std;
int n, ans;

bool isSame(int x,int y,int z){
	//每位均不能为3，7 
	if(x==3||x==7||y==3||y==7||z==3||z==7)
		return false;
	//两两不能相等 
	if(x == y || x == z || y == z)
		return false;
	return true;
}
 
int main(){
	cin >> n;
	for(int i = 1;i < n;i++){
		for(int j = 1;j < n;j++){
			if(n-i-j > 0 && isSame(i,j,n-i-j)){
				ans++;
			}		
		}
	} 
	cout << ans / 6;   //3位数全排列 6种情况，题意是需要去掉 
	return 0;
}

```
## 第三题（暂无）


