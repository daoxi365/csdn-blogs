@[toc]
# 压缩技术

## 题目描述

设某汉字由N × N的0和1的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个0，第二个数表示接下来连续有几个1，第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 （第一个数是N ,其余各位表示交替表示0和1 的个数，压缩码保证 N × N=交替的各位数之和）

## 输入格式

一行，压缩码。

## 输出格式

汉字点阵图（点阵符号之间不留空格）。（3<=N<=200）

## 样例 #1

### 样例输入 #1

```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```

### 样例输出 #1

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

## 题解
当时我看到这道题，觉得：啊很简单啊，直接输出不就完了。
一做，人傻了。所以永远不要把问题想得很简单啊！
![在这里插入图片描述](https://pic.2ge.org/cdn/?url=https://img-blog.csdnimg.cn/9e749801514c482aa48348bf2b4fcf6a.png)
有的时候，真的是“差之毫厘，失之千里”。我前面三次都没对，就改了一句程序就AC。

```cpp
// Author:PanDaoxi
#include <iostream>
using namespace std;
// 可以不用二维数组，直接一次数组
int a[40201];
int main(){
 	int n,m,k=0,text,tmp=1,t;
 	// m*m的方格
	cin>>m;
	while(cin>>n){
		// 使用的字符
		text=k%2;
		// 接下来，连着n个text
		t=tmp,tmp+=n;
		for(int i=t;i<tmp;i++){
			// 写入数组
			a[i]=text;
		}
		// 下一个数
		k++;
	}
	// 输出
	for(int i=1;i<=m*m;i++){
		cout<<a[i];
		// 如果当前字符的数量满足被m整除，就该换行了
		if(i%m==0) cout<<endl;
	}
	return 0;
}
```
可以用布尔类型的数组，进一步优化：

```cpp
// Author:PanDaoxi
#include <iostream>
using namespace std;
bool a[40201],text=true;
int main(){
 	int n,m,tmp=1,t;
	cin>>m;
	while(cin>>n){
		text=!text,t=tmp,tmp+=n;
		for(int i=t;i<tmp;i++){
			a[i]=text;
		}
	}
	for(int i=1;i<=m*m;i++){
		cout<<a[i];
		if(i%m==0) cout<<endl;
	}
	return 0;
}
```

![在这里插入图片描述](https://pic.2ge.org/cdn/?url=https://img-blog.csdnimg.cn/d204ae3344874637a06d92abadf6605e.png)
# 压缩技术（续集版）

## 题目描述

设某汉字由N × N的0和1的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个0，第二个数表示接下来连续有几个1，第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 （第一个数是N ,其余各位表示交替表示0和1 的个数，压缩码保证 N×N = 交替的各位数之和）

## 输入格式

汉字点阵图（点阵符号之间不留空格）。（3<=N<=200）

## 输出格式

一行，压缩码。

## 样例 #1

### 样例输入 #1

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

### 样例输出 #1

```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```

## 题解
费了好大的力气，终于搞下来了（我不行啊）
想了好多的办法，想了个奇怪的办法

```cpp
// Author:PanDaoxi
#include <iostream>
#include <cmath>
using namespace std;
int a[40200],n=0,point=0; // point储存下标
int main(){
	char x,y='0';
	while(cin>>x){ // 输入字符
		// 字符数+1
		n++;
		// 判断：如果现在的和刚才的一样
		if(x==y) a[point]++;
		// 如果不一样，更新字符
		else a[point++]++,y=x;
	}
	// 因为n*n的矩阵，那么n= n的算术平方根
	cout<<sqrt(n)<<" ";
    // 特殊值处理
	a[0]--,a[point]++;
	// 输出就完了
	for(int i=0;i<=point;i++){
		cout<<a[i]<<" ";
	}
	return 0;
}

```
![在这里插入图片描述](https://pic.2ge.org/cdn/?url=https://img-blog.csdnimg.cn/49ec1fce5318452f814cb02f96df9631.png)

